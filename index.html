<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body>
    <section id="numbering-list-items">
      <h1>给文本添加数字编号的小工具</h1>

      <label for="text-input">输入文本：</label>
      <br />
      <br />
      <textarea autofocus></textarea>
      <br />
      <br />
      <div class="container output">
        <label>结果文本：</label>
        <br />
        <br />
        <p id="p-output"></p>
      </div>
      <br />
      <br />

      <button onclick="handlecopy()">复制结果文本</button>
      <br /><br />
    </section>
    <script>
      const textArea = document.querySelector("textarea");
      const formatbutton = document.querySelector("#format-btn");
      const output = document.querySelector("#p-output");

      // todo: implement debounce

      const formatText = function (inputValue) {
        if (typeof inputValue === "string" && inputValue !== "") {
          const outputArray = new Array();
          inputValue
            .trim()
            .split("\n")
            .forEach((v, i) => {
              if (v !== "\n") {
                outputArray[i + 1] = `${i + 1}. ${v}；\n`;
              }
            });
          let outputText = outputArray.join("");
          return outputText;
        } else {
          return "";
        }
      };

      async function handleCopy() {
        await navigator.clipboard.writeText(output.innertext);
        // alert("复制成功！");
      }

      // @return {function} a function that will run `cb` with given `...args` arguments after `delay` ms
      function debounce(cb, delay = 1000) {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => {
            cb(...args);
          }, delay);
        };
      }

      function throttle(cb, delay = 1000) {
        let shouldWait = false;
        return (...args) => {
          if (shouldWait) {
            return;
          }

          // 执行回调
          cb(...args);

          // 上锁
          shouldWait = true;

          // 一秒后解锁
          setTimeout(() => {
            shouldWait = false;
          }, delay);
        };
      }

      const formatAndUpdateTextWithDebounce = debounce((text) => {
        output.innerText = formatText(text);
      });

      const formatAndUpdateTextWithThrottle = throttle((text) => {
        output.innerText = formatText(text);
      });
      textArea.addEventListener("input", (e) => {
        textArea.style.height = `20px`;
        textArea.style.height = `${textArea.scrollHeight}px`;
        // formatAndUpdateTextWithDebounce(e.target.value);
        formatAndUpdateTextWithThrottle(e.target.value);
      });
    </script>

    <style>
      * {
        box-sizing: border-box;
      }
      body {
        padding: 10px;
      }
      section {
        padding: 30px;
        margin: 15% 15%;
        border-style: dashed;
        border-width: 3px;
        border-radius: 5px;
      }
      textarea {
        margin: 0;
        padding: 5px;
        width: 100%;
        height: 100px;
        resize: vertical;
        border-radius: 5px;
        overflow: hidden;
        resize: none;
        font-size: 16px;
        line-height: 2em;
      }
      #p-output {
        width: 100%;
        margin: 0;
        padding: 5px;
        border-style: solid;
        border-width: 1.5px;
        border-radius: 5px;
        font-size: 16px;
        line-height: 2em;
      }
      button {
        min-width: max-content;
        min-height: max-content;
      }
    </style>
  </body>
</html>
